# DevOps

## Отчет по лабораторной работе №2

> ### Задание: "Плохой" докерфайл
>
> Написать “плохой” Dockerfile, в котором есть не менее трех “bad practices” по написанию докерфайлов

Напишем Dockerfile с плохими практиками:

```
    FROM python:3.7

    RUN apt-get update
    RUN apt-get install -y git
    RUN apt-get install -y curl

    WORKDIR /bad_docker/app

    ADD . .

    RUN pip install --no-cache-dir -r requirements.txt

    RUN echo "SECRET_TOKEN=12345" >> .env

    CMD ["python", "app.py"]
```

Пройдемся по строкам файла и посмотрим, какие именно плохие практики тут были реализованы:

1.  `FROM python:3.7`:

    -   **_Устаревший базовый образ_**: устаревший образ не получает обновлений безопасности и исправлений ошибок. Это делает систему уязвимой к потенциальным угрозам и может приводить к проблемам с совместимостью.

    -   **_Большой размер базового образа_**: тяжеловесные образы могут иметь большое множество ненужных для приложения зависимостей и инструментов, что увеличивает размер docker-образа и замедляет время его сборки и развертывания.

2.  `RUN apt-get update`

    `RUN apt-get install -y git`

    `RUN apt-get install -y curl`

    -   **_Множество команд RUN без объединения_**: каждая инструкция создает свой слой, соответственно увеличивается их количество в самом образе.
    -   **_Установка ненужных пакетов_**: каждый пакет увеличивает итоговый размер образа, а значит, не нужно устанавливать лишние пакеты, только из-за того, что, возможно, они понадобятся, но приложение так ими и не пользуется.
    -   **_Использование команды `RUN apt-get update` отдельно от `RUN apt-get install`_**: после сборки все слои находятся в кэше Docker, и если потом вы измените `apt-get install`, добавив дополнительный пакет, Docker пересоберет образ, начиная с измененной инструкции, а значит то, что было закэшировано в `apt-get update`, не изменится, и сборка потенциально получит старые версии пакетов.

3.  `ADD . .`

    `RUN pip install --no-cache-dir -r requirements.txt`

    -   **_ADD вместо COPY для просто копирования файлов_**: инструкция ADD позволяет решать те же задачи, что и COPY, но у нее также есть и другие функции, которые могут дать нежелаемый результат сборки. Команда ADD может распаковать архивы или загружать файлы по URL, а значит, это может привести к ошибкам или стать причной уязвимостей.
    -   **_Неоптимальная установка зависимостей_**: как мы знаем, при изменении докерфайла, пересборка начинается с места изменения, а то, что было до него, хранится в кэше и не меняется. Таким образом, установка зависимостей сразу после копирования всех файлов приводит к тому, что при любом изменении кода Docker пересобирает и слои с зависимостями, что значительно замедляет сборку.

4.  `RUN echo "SECRET_TOKEN=12345" >> .env`

    -   **_Хранение конфиденциальной информации в слоях_**: если секреты или конфиденциальные данные добавляются в файлы в слоях, они остаются в истории слоёв Docker, даже если их удалить позже. Это может привести к утечке данных.

5.  `CMD ["python", "app.py"]`

    -   **_Запуск от root пользователя_**: если не был создан пользователь с помощью инструкции USER, то по умолчанию контейнер будет запускаться от пользователя root, что представляет собой угрозу безопасности.

-   Запуск плохого контейнера
    _скриншот_

-   При сборке получаем следующее предупреждение:
    _скриншот_

Т.е. образ для контейнера создается, его можно использовать, но даже на уровне компилятора мы получаем указание на одну из неправильных
практик в написании docker-файла.
«ВНИМАНИЕ: запуск pip от имени пользователя root может привести к нарушению разрешений и конфликтному поведению с системным менеджером
пакетов. Вместо этого рекомендуется использовать виртуальную среду: https://pip.pypa.io/warnings/venv.»

-   Сборка занимает *с, *Гб
    _скриншот_

-   Получаем образ контейнера, который можно посмотреть в программе Docker Desktop
    _скриншот_

-   Создается контейнер
    _скриншот_

> ### Задание: "Хороший" Dockerfile
>
> Написать “хороший” Dockerfile, в котором эти плохие практики исправлены

Исправим Dockerfile

```
    FROM python:3.9-slim

    RUN apt-get update && apt-get install -y --no-install-recommends \
        && rm -rf /var/lib/apt/lists/*

    WORKDIR /good_docker/app

    COPY requirements.txt .

    RUN pip install --no-cache-dir -r requirements.txt

    COPY . .

    USER nobody

    CMD ["python", "app.py"]
```

---

> ### Задание
>
> Описать как исправление плохих практик повлияло на результат

Видимо должна увеличится скорость сборки контейнера и уменьшится размер образа. Компилятор не кидает предупреждение и сам образ стал более безопасным,
простым в использовании.
Хорошая практика — это создание предсказуемых и безопасных контейнеров, с минимальными слоями, точными версиями зависимостей и отсутствием лишних файлов.
Это улучшает производительность, снижает размер образа и повышает стабильность развертывания.

---

> ### Задание
>
> В Readme описать 2 плохих практики по работе с контейнерами.

-   Настройте централизованное логирование, чтобы собирать логи из контейнеров и облегчить их анализ.
-   Какая-то вторая
